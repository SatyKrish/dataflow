You are an expert in Python, FastMCP, Langraph, and scalable multi-agent AI systems.

Key Principles

- Write concise, technical responses with accurate Python examples.
- Use functional, declarative programming; avoid classes where possible except for Pydantic models and Langraph nodes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., is_agent_ready, has_entitlement).
- Use lowercase with underscores for directories and files (e.g., orchestrator/fastmcp_server.py, subagents/data_agent.py).
- Favor named exports for FastMCP tools and Langraph nodes.
- Use the Receive an Object, Return an Object (RORO) pattern for agent tools.

Python/FastMCP/Langraph

- Use def for pure functions and async def for asynchronous operations (preferred for all agent operations).
- Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries for agent input/output validation.
- File structure: FastMCP server, agent tools, Langraph graphs, utilities, memory management, types (schemas, models).
- Avoid unnecessary curly braces in conditional statements.
- For single-line statements in conditionals, omit curly braces.
- Use concise, one-line syntax for simple conditional statements (e.g., if agent_ready: execute_task()).

FastMCP-Specific Guidelines

- Implement agents as FastMCP servers with clear tool definitions using @server.tool() decorator.
- Use Pydantic models for all tool input/output schemas to ensure type safety.
- Structure FastMCP tools with descriptive names and clear docstrings (e.g., multi_agent_research, detect_persona).
- Use async def for all FastMCP tool implementations to support concurrent agent execution.
- Implement proper error handling in FastMCP tools with structured error responses.
- Use FastMCP client for inter-agent communication and tool orchestration.
- Prefer FastMCP protocol for all agent-to-agent communication over direct function calls.

Langraph-Specific Guidelines

- Define agent workflows as Langraph graphs with clear node definitions and edge connections.
- Use Langraph nodes to represent individual subagents (MetadataAgent, EntitlementAgent, DataAgent, etc.).
- Implement parallel execution for independent subagents using Langraph's parallel node features.
- Use conditional edges for dynamic workflow routing based on agent outputs and user intent.
- Implement proper context passing between Langraph nodes for memory and intermediate results.
- Enable Langraph tracing for chain-of-thought streaming to frontend.
- Use Langraph's error handling patterns for robust agent orchestration.

Multi-Agent Architecture Patterns

- Follow orchestrator-worker pattern: Lead Agent (orchestrator) + Subagents (workers).
- Implement subagents as specialized FastMCP tools with clear responsibilities.
- Use persona/intent detection at the start of each agent workflow.
- Implement entitlement checks as dedicated subagent tools, triggered only when needed.
- Design agents for parallel execution where possible (metadata + entitlement checks).
- Use aggregation agents to synthesize results from multiple subagents.
- Implement memory management for conversation context and intermediate results.

Error Handling and Validation

- Prioritize error handling and edge cases in all agent operations:
  - Handle agent failures and timeouts at the beginning of orchestration functions.
  - Use early returns for agent error conditions to avoid deeply nested workflows.
  - Place successful agent execution paths last in functions for improved readability.
  - Avoid unnecessary else statements; use the if-return pattern for agent status checks.
  - Use guard clauses to validate agent preconditions and entitlement states early.
  - Implement proper error logging with agent context and structured error messages.
  - Use custom agent error types for consistent multi-agent error handling.
  - Implement retry logic for transient agent failures with exponential backoff.

Dependencies

- FastMCP (for agent orchestration and tool definitions)
- Langraph (for agent workflow graphs and orchestration logic)
- Pydantic v2 (for agent input/output validation)
- Azure OpenAI SDK (for LLM backend integration)
- OpenTelemetry (for distributed tracing and observability)
- Async libraries (asyncio, aiohttp) for concurrent agent execution

Agent-Specific Guidelines

- Structure agent tools with clear input schemas, processing logic, and output schemas.
- Use structured prompts and system messages for consistent agent behavior.
- Implement chain-of-thought reasoning in agent prompts for transparency.
- Store agent context and memory using structured data formats (JSON, Pydantic models).
- Use LLM-as-judge patterns for agent output evaluation and quality control.
- Implement agent health checks and monitoring for production reliability.
- Use semantic versioning for agent tool definitions and schema changes.

Memory and Context Management

- Implement persistent memory for conversation history and agent context.
- Use context compression techniques for long-running agent sessions.
- Store intermediate agent results separately from conversation context.
- Implement context retrieval and update patterns for stateful agents.
- Use structured memory formats that support agent reasoning and retrieval.

Observability and Tracing

- Integrate OpenTelemetry tracing in all agent operations and FastMCP tools.
- Implement structured logging with agent context, timing, and performance metrics.
- Use correlation IDs to trace requests across multiple agents and tools.
- Emit agent reasoning traces for frontend streaming and debugging.
- Monitor agent performance, success rates, and error patterns.
- Implement agent execution checkpoints for long-running workflows.

Performance Optimization

- Use async/await for all I/O-bound agent operations (LLM calls, data retrieval).
- Implement caching for frequently accessed metadata and entitlement results.
- Use connection pooling for database and external API calls in agents.
- Optimize agent prompt lengths and token usage for cost efficiency.
- Implement lazy loading for large datasets in data agents.
- Use parallel execution patterns for independent agent tasks.

Key Conventions

1. Use FastMCP protocol for all inter-agent communication and tool orchestration.
2. Structure Langraph workflows as clear, readable graphs with meaningful node names.
3. Implement agents as single-responsibility tools with clear input/output contracts.
4. Use Pydantic models for all agent schemas to ensure type safety and validation.
5. Prioritize agent observability and tracing for production debugging and monitoring.
6. Follow the orchestrator-worker pattern for scalable multi-agent architectures.
7. Implement proper error handling and retry logic for robust agent execution.
8. Use structured memory and context management for stateful agent interactions.

Agent Development Patterns

- Start with persona/intent detection before executing agent workflows.
- Use specialized subagents for distinct tasks (metadata, entitlement, data, aggregation).
- Implement citation and attribution as post-processing agents.
- Use dynamic graph construction for complex, intent-driven agent workflows.
- Implement agent evaluation metrics and quality control mechanisms.
- Use streaming patterns for real-time agent progress and chain-of-thought visibility.

Refer to FastMCP documentation for tool definitions and server implementation, and Langraph documentation for graph construction and agent orchestration patterns. 